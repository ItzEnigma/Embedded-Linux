# Contents

- [Contents](#contents)
  - [BuildRoot: Making Embedded Linux Easy](#buildroot-making-embedded-linux-easy)
    - [Download BuildRoot](#download-buildroot)
    - [Download Necessary Dependencies](#download-necessary-dependencies)
    - [Initialize BuildRoot](#initialize-buildroot)
    - [Configurations Requirements](#configurations-requirements)
    - [Create/Add Custom Package](#createadd-custom-package)
    - [Qemu Emulation](#qemu-emulation)
      - [SSH Connection](#ssh-connection)
      - [NFS Connection](#nfs-connection)
    - [Real Target Generation](#real-target-generation)
      - [Raspberry PI Image](#raspberry-pi-image)
      - [Configuration Requirements](#configuration-requirements)
  - [SystemV](#systemv)
    - [Modify `inittab`](#modify-inittab)
    - [Create `rc.d` directory with subdirectories](#create-rcd-directory-with-subdirectories)
    - [Create `rc` script](#create-rc-script)
      - [Add Service Script](#add-service-script)
  - [Systemd](#systemd)
    - [Create Unit File](#create-unit-file)
    - [Unit File Structure](#unit-file-structure)
    - [Running Service](#running-service)
  - [SystemV vs SystemD](#systemv-vs-systemd)

## BuildRoot: Making Embedded Linux Easy

Buildroot is an **open-source project** that provides a framework for building embedded Linux systems. It simplifies and **automates** the process of generating a `root filesystem`, `kernel image`, `bootloader`, and `other components` necessary for embedded devices.

//TO BE MODIFIED > BuildRoot is licensed under **_GPL v2_** !

---

### Download BuildRoot

We will be working on a specific tag ... to make sure no weird errors occur!

```bash
# git clone https://github.com/buildroot/buildroot.git     # But we will be working on a specific tag
wget https://buildroot.org/downloads/buildroot-2024.02.tar.gz
tar -xvzf buildroot-2024.02.tar.gz
```

---

### Download Necessary Dependencies

Install necessary dependencies

```bash
sudo apt install sed make binutils gcc g++ bash patch gzip bzip2 perl tar pio python unzip sync wget libncurses-dev
sudo apt-get install libncurses5-dev libncursesw5-dev
```

---

### Initialize BuildRoot

We will be **emulating** **`qemu_arm_versatile_defconfig`** ... but we can make for any target!

```bash
ls configs/     # Shows all pre-made available configuration
ls configs/ | grep qemu_arm_v       # Shows qemu configurations
ls board/       # Shows all boards

# We will be using (emulating) this target

make menuconfig         # Choose configurations needed!

make           # It might take sometime 30mins : 2hours+
```

**`make clean`**

- is a command used to remove **intermediate or temporary files** generated during the build process. These files are typically object files _(\*.o)_, dependency files, and other build artifacts.
- allows a fresh build without any remnants from **previous builds**.
- **It doesn't remove files that are generated as part of the distribution process or configuration files ... `OR ANYTHING DOWNLOADED`**.

**`make distclean`** ... **More thorough clean**

- in addition to removing intermediate files like **`make clean`**, **`make distclean`** also removes files that are generated as part of the distribution process, such as **compiled binaries, libraries, configuration files** generated by `configure`, and any other files created during the build process.
- **returns the project directory to a state similar to its original distribution or source state**.

> :white_check_mark: After finishing ... the output will be on ./output/ directory ... containing all the images

### Configurations Requirements

- [ ] Change **`toolchain vendor name`**
- [ ] Enable **`C++ Support`**
- [ ] Change **`System hostname`** & **`System banner`**
- [ ] Apply **`root password`**
- [ ] Create your own **`package`** _(add it to menuconfig)_
- [ ] Enable **`ssh communication`** _(not **openssh** ... lightweight one -> **dropbear**)_
- [ ] Choose a **`game`**
- [ ] Choose **`SystemV`** ... then after starting your machine, modify the SystemV script `inittab` and add _`(init.d)/rc`_ and finally **soft-link** your scripts to be run to the _`rcN.d`_ directory.

> You can add your **custom packages** to the **menuconfig** by manipulating configurations!
>
> :grey_exclamation: for **`qemu`** you can choose the starting point to be the **`kernel`** **not** the **`bootloader`**!

---

### Create/Add Custom Package

There are **two main methods** to add a custom package into buildroot. The first method includes adding a package directly into the source tree which is discussed. The second involves the use of an external package tree which isn't discussed here.

Let us consider that you have a custom package **`(yourpckg)`** that you would like to include in your Root FS created with buildroot. This package will consist of a source file and a makefile in the most straightforward case ... **steps:**

1. Create a **package directory** under the **`${PATH_TO_BUILDROOT}/package/`**
2. Inside your created package directory _(for example **`yourpckg/`**)_ ... create **`Config.in`** file and **`yourpckg.mk`**
3. Then create a **`src`** **directory** that will contain your **`source file`** to be **compiled** and **`Makefile`**
4. Finally, **modify** **`${PATH_TO_BUILDROOT}/package/Config.in`** to add your package **_`yourpckg`_** into **`menuconfig`** menu.

---

**`package/yourpckg/Config.in`**

```config
config BR2_PACKAGE_YOURPCKG
	bool "yourpckg"
	help
		Write any help message which is to be displayed

		https://github.com/ItzEnigma
```

**`package/yourpckg/yourpckg.mk`**

```mk
################################################################################
#
# your package
#
################################################################################

YOURPCKG_VERSION = 1.0
YOURPCKG_SITE = ./package/YOURPCKG/src
YOURPCKG_SITE_METHOD = local

define YOURPCKG_BUILD_CMDS
    $(MAKE) CC="$(TARGET_CC)" LD="$(TARGET_LD)" -C $(@D)
endef

define YOURPCKG_INSTALL_TARGET_CMDS
    $(INSTALL) -D -m 0755 $(@D)/yourpckg $(TARGET_DIR)/usr/bin
endef

$(eval $(generic-package))
```

**`package/yourpckg/src/yourpckg.c`**

```c
#include <stdio.h>

int main(void) {
    printf("yourpckg printing ...");
}
```

**`package/yourpckg/src/Makefile`**

```Makefile
.PHONY: clean
.PHONY: yourpckg

yourpckg: yourpckg.c
	$(CC) -o '$@' '$<'

clean:
	-rm yourpckg
```

**Finally modify `package/Config.in`**

```
menu "Misc"
    source "package/yourpckg/Config.in"
endmenu
```

> :exclamation: Make sure to use **`indent tab` NOT `spaces`**... **especially with make files ... or it will cause errors and build failures** ... and don't use comments!

> :grey_exclamation: Obviously you can replace **`yourpckg`** with any name that you want to use for your package :)

> :white*check_mark: After finishing ... you should be able to find the packageg in the menuconfig ... and you can build this package or everything *(if it wasn't done before)\_

|         command          |                       description                       |
| :----------------------: | :-----------------------------------------------------: |
|     `make yourpckg`      |       Build the package and install it on target        |
| `make yourpckg-dirclean` |       Remove the build directory for the package        |
| `make yourpckg-rebuild`  | restart the compilation and installation of the package |

---

### Qemu Emulation

After completion ... then the output will be generated, and you should find the `image` & `dtb` & `sdimg` _(or rootfs partition)_ ... in the **`./output/images`** ... and a script to run.

> :grey_exclamation: Running the qemu script might cause an issue, where `Ctrl+C` closes the emulator ... you can solve this by executing the qemu script, not running the generated one!

You can `alias` the qemu script and put it into **`.bashrc`** ... to not need to write the whole command everytime:

```bash
# This is the qemu script for booting the generated image
sudo qemu-system-arm -M versatilepb -kernel zImage -dtb versatile-pb.dtb -drive file=rootfs.ext2,if=scsi,format=raw -append "rootwait root=/dev/sda console=ttyAMA0,115200 " -net tap,script=./qemu-ifup  -net nic,model=rtl8139  -nographic

# You can alias, and put it into .bashrc
alias qemu-versatile='sudo qemu-system-arm -M versatilepb -kernel zImage -dtb versatile-pb.dtb -drive file=rootfs.ext2,if=scsi,format=raw -append "rootwait root=/dev/sda console=ttyAMA0,115200 " -net tap,script=./qemu-ifup  -net nic,model=rtl8139  -nographic`
```

> :grey_exclamation: This enables the **`tap`** virtual interface.

> The **`qemu-ifup script`** creates the virtual tap on your host while running the `qemu emulator`!

```bash
# You can replace the ip address with any ip BUT,
# don't forget the subnet!
# The argument $1 ... is the tap interface which is located inside /dev/

ip a add 192.168.0.1/24 dev $1
ip link set $1 up
```

#### SSH Connection

For qemu emulation, first you have to make sure that **`tap` virtual interface** is created and up ... check **`ifconfig`** on your **host** after running the **qemu emulation** to check if it was created ... **If not check your qemu script!**

You should find the tap interface in your host with a **specific ip and `subnet`** _(which is given by the qemu script)_ ... now inside your qemu emulator run the following:

```bash
# After running ifconfig ... tap0 --> inet 192.168.0.1

# Inside the qemu emulation ... run ifconfig or ip a
# You should find that your ethernet eth0 for example
# has no ip ...
ip a add 192.168.0.77/24 dev eth0
ip a    # or ifconfig
# after re-running the command you should find that,
# eth0 has an ip now and you can ping your tap
ping 192.168.0.1

# Now you're ready ... you can connect using ssh!

# From your host
ssh root@192.168.0.77       # Then enter password!
```

> :exclamation: Make sure that your **virtual tap** and **ip inside qemu** are over the same **`subnet`**.

#### NFS Connection

Network File System _(NFS)_ connection for mounting `Rootfs`

```bash
# Install the nfs server on your host
sudo apt install nfs-kernel-server
```

---

### Real Target Generation

**Mounting SD Card** ... upon mounting, the partitions will be added ... you can check the partition name using:

```bash
dmesg       # print or control the kernel ring buffer
```

Coping generated sd.img to the sdcard ... You can **hard format** the sdcard manually/ or you can just copy the image

```bash
# Note: change sdc --> your sdcard drive name
sudo dd if=/dev/zero of=/dev/sdc     # Hard Format

sudo dd if=sd.img of=/dev/sdc        # Soft Format & Just copy the image
```

#### Raspberry PI Image

```bash
# While in buildroot directory
# You can readreadme file

nano board/raspberrypi3/readme.txt

# Select Configuration for raspberrypi3_64_defconfig
make raspberrypi3_64_defconfig

# You can edit configurations if needed
make menuconfig
```

> :grey_exclamation: `zImage` is compressed is for **32-bit** arch. ... while the `Image` is for **64-bit** arch.

#### Configuration Requirements

- [ ] Change **`System hostname`** & **`System banner`**
- [ ] Apply **`root password`**
- [ ] Create your own **`package`** _(add it to menuconfig)_
- [ ] Enable **`ssh communication`** _(**openssh**)_
- [ ] Add `python3`

---

## SystemV

System Five _(SysV)_ init is one of the earliest init systems used in Unix-like operating systems. It follows a **sequential and script**-based approach to **starting and stopping system services** for system initialization. System V init uses a series of **runlevels** to define the state of the system and the services that are running ... The **Init Process** reads **`inittab`** configurations and runs the corresponding scripts for services.

- **Script-Based Configuration:** SysV init relies heavily on shell scripts located in directories like **`/etc/init.d/`** and **runlevels** specified in directories like **`/etc/rc*.d/`**.
- **Limited Parallelization:** SysV init processes start services **sequentially**, leading to slower boot times on systems with many services.
- **Lacks Dependency Management:** Managing dependencies between services in SysV init scripts requires **manual handling within the scripts**.

After choosing **`SystemV`** ... and starting the machine ... it's time to modify **SystemV**

### Modify `inittab`

In a **SystemV init system**, **`/etc/inittab`** is used to configure the behavior of the **init process**, including specifying the default `runlevel` and defining `actions` for various `events` such as **system startup, shutdown, and console management**.

There are **8 runlevels**, numbered from 0 to 6, plus S:

- **S:** run startup task
- **0:** Halts the system
- **1 to 5:** Available for general use
- **6:** Reboots the system

**`inittab`** file modifications to be added:

```text
# Run Levels
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6
```

### Create `rc.d` directory with subdirectories

Runlevel directory **`rc.d`** needs to be created and also create the **`rcN.d`** sub-directories **for each runlevel** **`(/etc/rc.d/rc[1-5].d/)`**. These directories contain symbolic links to specific scripts inside **`/etc/init.d`**, indicating which services should be started or stopped when the system enters a particular runlevel.

```sh
# Create rc.d directory
mkdir /etc/rc.d

# Create rcN.d sub-directories
cd /etc/rc.d/
mkdir rc1.d rc2.d rc3.d rc4.d rc5.d
```

### Create `rc` script

The script is responsible for managing **runlevels** and **executing** the specific scripts in **`/etc/init.d`** or correspondingly, the **soft-linked** scripts in **`/etc/rc.d/rcN.d/`** ... based on which run level.

```sh
#!/bin/sh

# SystemV init script for different runlevels

# Check if a runlevel argument is provided
if [ -z "$1" ]; then
	echo "Usage: $0 <runlevel>"
	exit 1
fi

# Determine the target runlevel
RUNLEVEL=$1

# Define the path to the init.d and rc.d directories
INIT_D_DIR="/etc/init.d"
RC_D_DIR="/etc/rc.d/"

# Function to start or stop services based on their
# initial 'S' or 'K'
manage_services()
{
	local rc_dir="$1"
	echo "Executing services for runlevel $RUNLEVEL..."
	for service in "$RC_D_DIR"/"$rc_dir"/*; do

		# Ignore dangling symlinks (if any).
     	[ ! -f "$service" ] && continue

		if [ -x "$service" ]; then
            # Check if the service name starts with 'S' or 'K'

			case "$(basename "$service")" in
				S* )
					trap - INT QUIT TSTP
					"$service" "start"
					;;
				K* )
					trap - INT QUIT TSTP
                    "$service" "stop"
					;;
				* )
					# Do Nothing!
					;;
			esac
		fi
	done
	echo "Finished Executing services for runlevel $RUNLEVEL!"
}


# Determine the action based on the runlevel
case "$RUNLEVEL" in
	1)
		manage_services "rc1.d"
		;;
	2)
		manage_services "rc2.d"
		;;
    3)
		manage_services "rc3.d"
        ;;
	4)
		manage_services "rc4.d"
		;;
	5)
		manage_services "rc5.d"
		;;
	*)
		echo "Unsupported runlevel: $RUNLEVEL"
        exit 1
        ;;
esac

exit 0
```

#### Add Service Script

Create the **service script** inside **`/etc/init.d`** directory ... that will be executed during the specific runlevel ... **the script shall contain the application/binaries/scripts to be run!**

```sh
# Create the script inside init.d
vim anyservice
# Example --> vim enigmapckg

# ... After adding the script
# Make Sure To chmod to be executable!!!
chmod +x anyservice
```

```sh
#!/bin/sh
# Running Enigma Service ...

case "$1" in
      start)
           echo "Starting Enigma Service........."
           start-stop-daemon -S -n enigmasrv -a /usr/bin/enigmapckg &
           # Could be any script or binary rather enigmapckg
           ;;
     stop)
           echo "Stopping Enigma Service........."
           start-stop-daemon -K -n enigmasrv
           # Could be any script or binary rather enigmapckg
           ;;
	restart)
    		echo "Restarting Enigma Service........"
    		$0 stop
    		$0 start
    		;;
     *)
           echo "Usage: $0 {start|stop}"
           exit 1
esac
exit 0
```

> :grey_exclamation: You can test this service script by running it with start argument **`./enigmapckg start`**

Finally, you can **soft-link** the specific scripts to the corresponding runlevel

```sh
# Service Script to be started 'S'
ln -s /etc/init.d/enigmapckg /etc/rc.d/rc3.d/S40enigmapckg

# Service Script to be stopped 'K'
ln -s /etc/init.d/enigmapckg /etc/rc.d/rc4.d/K40enigmapckg
```

## Systemd

System Daemon is an init system process, that manage system settings and services. systemd organizes tasks into components called **units**, and groups of units into **targets**, that can be used to create dependencies on other system services and resources. **systemd can start units and targets automatically at boot time, or when requested by a user or another systemd target when a server is already running.**

The **`systemctl`** command is used to interact with processes that are controlled by **systemd**. It can examine the **`status`** of units and targets, as well as **`start`**, **`stop`**, and **`reconfigure`** them

- **Event-Driven and Parallel Initialization:** systemd initializes services in **parallel** whenever possible, resulting in **faster boot times**. It also utilizes sockets and D-Bus for communication, **allowing services to be started on-demand as needed**.
- **Unit Files:** systemd uses declarative unit files **`(*.service, *.socket, *.target, etc.)`** instead of shell scripts for service configuration. These unit files provide more flexibility and are easier to manage.
- **Dependency Management:** systemd handles service dependencies automatically based on the directives specified in unit files, simplifying service management.
- **Logging and Monitoring:** systemd includes advanced logging and monitoring capabilities through the **journal** **`(systemd-journald)`**, which centralizes system logs and provides efficient querying and filtering capabilities.

### Create Unit File

Typically stored in the **`/usr/lib/systemd/system/`** directory or **`/etc/systemd/system/`** directory **_(Usually as soft-link)_**. You can create your unit file with a **.service** extension, as most unit files correspond to services.

```bash
cd /lib/systemd/system
sudo vim enigma.service # Create service
```

### Unit File Structure

- **`Unit:`** This section defines **metadata** and **dependencies** for the unit.
- **`Service:`** The Service section contains details about the **execution** and **termination** of service.
- **`Install:`** handles the installation of a systemd service/unit file. This is used when you run either **systemctl enable** and **systemctl disable** command for enabling or disabling a service.

```bash
[Unit]
Description=My Enigmatic Service
# Requires --> Starts the specified service
Requires=tftpd-hpa.service
# After --> Starts this service after the specified service has been started and finished
After=tftpd-hpa.service

[Service]
Type=simple
ExecStart=/bin/enigmapckg

[Install]
WantedBy=multi-user.target
```

### Running Service

Enable and start the service and check status

```bash
# Useful for when starting the runlevel (target) ...
# to auto start the service
sudo systemctl enable enigma.service

sudo systemctl start enigma.service	# Starts the service

sudo systemctl status enigma.service

# You can also check journal logs
journalctl

# For current boot journal logs
journalctl -k
```

---

## SystemV vs SystemD

:bulb: SystemV and Systemd are both **init systems** for Unix-like operating systems, responsible for **initializing and managing system services, processes, and daemons**. However, they have significant differences in design, features, and operation

|            `SystemV`            |          `SystemD`           |
| :-----------------------------: | :--------------------------: |
|   **Sequential** script-based   | Parallelization event-driven |
|      Uses **init scripts**      |     Uses **unit files**      |
|        Slower boot-time         |       Faster boot-time       |
| Default for modern distribution |   Common in older systems    |
|  Provides Dependency mangement  |  Must be handled in scripts  |
