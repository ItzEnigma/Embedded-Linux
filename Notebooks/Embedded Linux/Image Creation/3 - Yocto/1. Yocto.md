# Contents

- [Contents](#contents)
  - [yocto project](#yocto-project)
    - [yocto Main Target](#yocto-main-target)
    - [Host Requirements](#host-requirements)
    - [Download yocto](#download-yocto)
      - [Packages Requirements](#packages-requirements)
  - [Build Directory Structure](#build-directory-structure)
    - [`build/cache` Directory](#buildcache-directory)
    - [`build/conf` Directory](#buildconf-directory)
    - [`build/downloads/` Directory](#builddownloads-directory)
    - [`build/sstate-cache/` Directory](#buildsstate-cache-directory)
    - [`build/tmp/` Directory](#buildtmp-directory)
  - [Poky Configuration](#poky-configuration)
    - [oe-init-build-env](#oe-init-build-env)
    - [Configuration](#configuration)
    - [Qemu Image Build](#qemu-image-build)
      - [Qemu Emulation](#qemu-emulation)
  - [Real Target Generation (RPI4)](#real-target-generation-rpi4)
    - [Add meta-RPI `meta-layer`](#add-meta-rpi-meta-layer)
    - [Create and Modify RPI configuration](#create-and-modify-rpi-configuration)
    - [Add the layer to `bblayer.conf`](#add-the-layer-to-bblayerconf)
    - [RPI4 Image Build](#rpi4-image-build)
    - [Boot RPI4](#boot-rpi4)
      - [Raspberry PI Power Supply](#raspberry-pi-power-supply)

---

## yocto project

**Yocto Project**, a comprehensive suite of `tools`, `templates`, and `resources` to **build custom Linux distributions for embedded devices**.

**yocto project** is **poky** ... The exact difference between Yocto and Poky is Yocto refers to the organization (like one would refer to _'canonical'_, the company behind _Ubuntu_ ), and Poky refers to the actual bits downloaded ( analogous to 'Ubuntu' ).

**Poky** is a complete software development environment for embedded systems. It includes tools, documentation, and recipes that allow you to create custom Linux-based systems for embedded products regardless of the hardware architecture ... mainly contains the **`bitbake`** task execution system and the **`OpenEmbedded`** build system.

---

### yocto Main Target

Prepare your computer to become a **Yocto Project development host**, obtain and install the build system, set up and configure a build environment, launch and
monitor the build process, and finally verify the build result by booting your newly built Linux OS stack in the QEMU emulator.

---

### Host Requirements

The Yocto Project’s build system makes use of **parallel processing** whenever possible. Therefore, a build host with multiple CPUs or a multicore CPU significantly reduces build time. Of course, **CPU clock speed** also has an impact on how quickly packages can be built.

Memory is also an important factor. BitBake, _the Yocto Project build engine_, **parses
thousands of recipes and creates a cache with build dependencies**. Furthermore, the
compilers require memory for data structures and more

The OpenEmbedded build system that you obtain from the project’s website **contains only
the build system itself—BitBake and the metadata that guide it**. **It does not contain any source packages for the software it is going to build**. These are automatically downloaded as needed while a build is running.

> :exclamation: **50+ GB is minimum requirements for yocto!**

---

### Download yocto

```bash
git clone https://github.com/yoctoproject/poky.git
cd poky/
git checkout dunfell  # Unless you are directly involved in Yocto Project development, there is no need to directly work with the master branch.
```

> :grey_exclamation: The Yocto Project team releases a new major version of the build system every **`6 months`**

#### Packages Requirements

```bash
sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev python3-subunit mesa-common-dev zstd liblz4-tool file locales libacl1
```

---

## Build Directory Structure

The area is created when you source the setup environment script that is found in the Source Directory **`(i.e. oe-init-build-env)`**. The **`TOPDIR`** variable points to the **Build** Directory. ...

This directory contains user configuration files and the output generated by the `OpenEmbedded` & `BitBake` build system in its standard configuration where the source tree is combined with the output.

- **BitBake** uses a **`cache`** to store information about tasks that have already been run. This cache is used to determine whether a task needs to be run again.
- **BitBake** uses a **`shared staging area`** to store the output of tasks. This staging area is used to determine whether a task needs to be run again. _(Significantly speeds-up the build process)_
- **BitBake** uses a **`work directory`** to store the output of tasks. This work directory is used to determine whether a task needs to be run again.
- **BitBake** uses a **`configuration`** system that allows you to set variables that can be used in recipes and configuration files.

---

### `build/cache` Directory

This directory contains several internal files used by the OpenEmbedded build system.

It also contains **`sanity_info`**, a text file keeping track of important build information such as the values of **`TMPDIR`**, **`SSTATE_DIR`**, as well as the name and version of the host distribution.

---

### `build/conf` Directory

Contains configurations for this build ... and it contain two substantial files:

- **`build/conf/local.conf`**: This configuration file contains all the local user configurations for your build environment. The `local.conf` file contains documentation on the various configuration options. Any variable set here overrides any variable set elsewhere within the environment unless that variable is hard-coded within a file _(e.g. by using ‘=’ instead of ‘?=’)_. **Some variables are hard-coded for various reasons but such variables are relatively rare.**

> :grey_exclamation: At a minimum, you would normally edit this file to select the target `MACHINE`, which package types you wish to use `(PACKAGE_CLASSES)`, and the location from which you want to access `downloaded` files `(DL_DIR)`.

- **`build/conf/bblayers.conf`**: This configuration file defines layers, which are directory trees, traversed by BitBake. The `bblayers.conf` file uses the **`BBLAYERS`** **variable** to list the layers BitBake tries to find.

---

### `build/downloads/` Directory

This directory contains downloaded upstream source tarballs. You can control the location of this directory through the **`DL_DIR`** **variable**.

---

### `build/sstate-cache/` Directory

This directory contains the shared state cache. You can control the location of this directory through the **`SSTATE_DIR`** **variable**.

---

### `build/tmp/` Directory

The OpenEmbedded build system creates and uses this directory for all the build system’s output. The **`TMPDIR`** **variable** points to this directory.

**BitBake creates this directory if it does not exist.** As a last resort, to clean up a build and start it from scratch _(other than the downloads)_, you can remove everything in the tmp directory or get rid of the directory completely. **_If you do, you should also completely remove the build/sstate-cache directory._**

The amount of data stored in this directory can eventually consume **many gigabytes** of hard disk space because it contains `extracted source downloads`, `cross-compilation toolchains`, `compilation output`, and `images for kernel` and `root file systems` for your target machines and more. ...

```bash
# To conserve disk space during a build, you can add
INHERIT += rm_work
```

**Directories Inside /tmp/:**

|     `Directory`     |                                                                 `Usage`                                                                  |
| :-----------------: | :--------------------------------------------------------------------------------------------------------------------------------------: |
|   **buildstats/**   |                                                         Stores build statistics                                                          |
|     **cache/**      |                                Caches the parsed metadata to speed-up future builds _(Speeds up builds)_                                 |
|     **deploy/**     |                                        Contains any _“end result”_ output from the build process                                         |
| **sstate-control/** |                      Contains shared state **manifest** files, recording the files installed by each `sstate task`                       |
|     **stamps/**     |                                  Holds information to track what tasks have run and when they have run                                   |
|     **`work/`**     | Contains architecture-specific work sub-directories for packages built by BitBake. All tasks execute from the appropriate work directory |

> :bulb: **For `cache/`** ... During subsequent builds, BitBake checks each recipe _(any files included or appended to it)_ to see if they have been modified. **Changes can be detected**, for example, through file modification time _(mtime)_ changes and _hashing_ of file contents. If no changes to the file are detected, then the parsed result stored in the cache is reused. If the file has changed, it is reparsed.
>
> :exclamation: **For `work/`** ... the source for a particular package is **unpacked**, **patched**, **configured** and **compiled** all within its own work directory. Within the work directory, organization is based on the package group and version for which the source is being compiled as defined by the **`WORKDIR`**.
>
> :bulb: `metadata` in a nutshell are layers.

---

## Poky Configuration

### oe-init-build-env

This script sets up the **OpenEmbedded** build environment. When you run this script, your Yocto Project environment is set up, a **`build`** Directory is created, your working directory becomes the Build Directory, and you are presented with some simple suggestions as to what to do next ... the script sets up the build environment’s irectory structure and initializes the core set of configuration files. **It also sets a series of shell variables needed by the build system**.

```bash
source oe-init-build-env [Give folder name to be created]
# Source means load the script into the current shell.
```

> **The script uses other scripts within the scripts directory to do the bulk of the work.**
>
> :grey_exclamation: By default, running this script without a Build Directory argument creates the build/ directory in your current working directory ... but you can provide a custom directory.
>
> ```bash
> source oe-init-build-env ~/mybuilds
> ```
>
> :exclamation: The OpenEmbedded build system does not support file or directory names that contain spaces.

---

### Configuration

In `local.conf`, various variables are set that influence how BitBake builds your
custom Linux OS stack.

```bash
# Lines starting with the hash mark (#) are comments.
BB_NUMBER_THREADS ?= “${@bb.utils.cpu_count()}”
PARALLEL_MAKE ?= “-j ${@bb.utils.cpu_count()}”
MACHINE ??= “qemux86”
DL_DIR ?= “${TOPDIR}/downloads”
SSTATE_DIR ?= “${TOPDIR}/sstate-cache”
TMP_DIR = “${TOPDIR}/tmp”
```

> :grey_exclamation: You can set the values to less than the cores in your system to **limit the load**.
>
> :grey_exclamation: `downloads` can be shared among **multiple build environments**. If BitBake detects that a source download is already available in the download directory, it does not download it again. **The same applies for `Shared State Cache`!**

---

### Qemu Image Build

Poky's default setting is to build qemu _[x86_x64]_ so we only need to run bitbake

```bash
# bitbake [options] [recipename/target ...]
bitbake core-image-minimal

# This -k option allows not breaking the build, if one package fails (unless there are dependencies on it)
bitbake core-image-minimal -k

# Instruct BitBake to download all the sources without building
bitbake -c fetchall core-image-minimal
```

> :exclamation: If you run into errors during bitbake ... **that fails the build**, ... if it's because running out of memory **and you get a similar error message for a different specific recipe:**
>
> ```bash
> Task (/home/enigma/Desktop/NTI/yocto/poky/meta/recipes-devtools/gcc/gcc_13.2.bb:do_compile) failed with exit code '1'
> ```
>
> **First, try to retry and if you still get the same issue! then do the following:**
>
> ```bash
> bitbake -c cleanstate gcc
> # You should change gcc with the specific package that is failing
> ```
>
> **If it still fails ... then try to modify local.conf for the following:**
>
> ```bash
> ##### Please replace number of cores with your host cores and multiply it by the number next to it #####
> BB_NUMBER_THREADS ?= "1.5 * Number of cores"
> PARALLEL_MAKE ?= "-j 2 * Number of cores"
>
> #### EXAMPLE #####
> ## my machine has 4 cores ##
> BB_NUMBER_THREADS ?= "6"
> PARALLEL_MAKE ?= "8"
>
> ## NUMBER OF CORES MUST BE PAIR ##
> ```
>
> **Then apply the cleanstate and re-try** > **If you still get the same issue, try to increase SWAP Virtual Memory Size!**
>
> > :exclamation: **This is only for the running out of memory problem, if it's a different error ... then search online !!!**
>
> :exclamation: If you run into many errors either **compilation of some recipes fails or random internet download speed drop** ... try to switch to **`tty terminal` and close `GUI`** ... as it saves resources and optimizes process!

---

#### Qemu Emulation

The Yocto Project uses an implementation of the Quick EMUlator _(QEMU)_

QEMU is an emulator and virtualization machine that allows you to run a complete image you have built using the Yocto Project as just another task on your build system. QEMU is useful for running and testing images and applications on supported Yocto Project architectures without having actual hardware.

> :grey_exclamation: Make sure QEMU Environment is set-up

Poky provides a convenient **script** that prepares the **QEMU execution environment and launches the emulator with the proper kernel and root file system images.**

:exclamation: **Run the `oe-init-build-env` script for poky environment initialization then:**

```bash
# runqemu [option ] [...]
runqemu qemux86-64    # This is the core-image-minimal

# OR you can --> runqemu /path/to/poky/build/tmp/deploy/images/qemux86-64

runqemu nographic     # To run without graphical window

# You can run --help to get more information
runqemu --help
```

---

## Real Target Generation (RPI4)

### Add meta-RPI `meta-layer`

```bash
git clone git://git.yoctoproject.org/meta-raspberrypi
```

> **You can also clone meta-openembedded for extra layers and packages**
>
> ```bash
> git clone git://git.openembedded.org/meta-openembedded
> ```

### Create and Modify RPI configuration

> :bulb: **We will make a custom output directory ... for better organization!**

```bash
# Add the raspberry pi meta-layer (And any necessary layers)
source oe-init-build-env build-rpi4/
# Will be called build-rpi4 ... you can choose any name
```

Modify the local.conf configurations.

```bash
# Once your inside /path/to/your/poky/build-rpi4/
cd conf/
vim local.conf

# Then edit:

# It should depend on your machine ... mine was rasp4
MACHINE ??= "raspberrypi4-64" # Choose RPI4-64bit machine

# Make sure that the download, sstate_cache and tmp directory is the same for all your custom distributions builds
# To save disk-space & time
DL_DIR ?= "${TOPDIR}/../build/downloads"
SSTATE_DIR ?= "${TOPDIR}/../build/sstate-cache"
TMPDIR = "/path/to/your/poky/build/tmp"

# Add packages to the image (Optional)
IMAGE_INSTALL:append = " bash vim ncurses openssh readline"

# Change the default shell (Optional)
# But make sure that the shell is installed in the image
SHELL = "/bin/bash"

# Enable the serial console
ENABLE_UART = "1"

# RM_OLD_IMAGE: Reclaims disk space by removing previously built versions of the same image
RM_OLD_IMAGE = "1"

# Delete work files ... to save disk space as the build progresses
INHERIT += "rm_work"

# Exclude some recipes from having their work directories deleted by rm_work
RM_WORK_EXCLUDE += "openssh"

# Enable the creation of an SD card image
IMAGE_FSTYPES="tar.bz2 ext3 rpi-sdimg"
```

> **`RM_OLD_IMAGE:`** Reclaims disk space by removing previously built versions of the same image from the images directory pointed to by the DEPLOY_DIR
>
> **`INHERIT`** ... is a variable that specifies classes to inherit from.
>
> **`rm_work`** class supports deletion of temporary workspace, which can ease your hard drive demands during builds.

### Add the layer to `bblayer.conf`

```bash
BBLAYERS ?= " \
  /path/to/your/poky/meta \
  /path/to/your/poky/meta-poky \
  /path/to/your/poky/meta-yocto-bsp \
  /path/to/your/poky/meta-raspberrypi \
  "
```

> :exclamation: Make sure it's an absolute path!

### RPI4 Image Build

```bash
# This -k option allows not breaking the build, if one package fails (unless there are dependencies on it)
bitbake core-image-minimal -k
```

> :exclamation: If you run into errors during bitbake ... **that fails the build**, ... if it's because error while fetching a specific recipe's package **(raspberrypi linux)** ... it might be because: **unstable internet connection, or just significant speed drop during downloading a big sized package ...**
>
> > **Retry and if you still get the same issue `but your sure that your internet connection is stable!` then do the following:**
> > You're getting a progress in the download ... switch to **`tty terminal` and close `GUI`** ... as it saves resources and optimizes process!

:white_check_mark: **If you get a successful build ... then put the image on SD card and boot on your RPI4!**

```bash
# Make sure your location is /path/to/poky/build/tmp/deploy/images/raspberrypi4-64
sudo dd if=./core-image-minimal-raspberrypi4-64.rpi-sdimg of=/dev/sd<x>
# Change sd<x> with your SD card location ...

lsblk   # To check the location of your SD card
```

> :bulb: `.manifest` file inside the deploy/images directory contains a **list of what went into the image** ... _(packages)_

### Boot RPI4

- Insert the SD card into the RPI4
- Connect to Raspberry PI

  - You can use **`HDMI`** to connect to a monitor and keyboard to interact with the RPI4 **(not recommeneded)**.
  - You can use usb-to-ttl (or serial) cable to connect to the RPI4 **(recommended)**.

  ```bash
      # Connect from your host to the RPI4 using monitor
      sudo screen /dev/ttyUSB0 115200

      # Usually the ttyUSB0 is the default port & 115200 is the default baudrate
  ```

- After making sure everything is set, **power on the RPI4**.

#### Raspberry PI Power Supply

> :exclamation: It's recommended to use power supply with **`5V 3A`** for RPI4! or power it using usb from powerbank _`(that can supply 5V 3A)`_ with **protection circuit and regulation!** ...
>
> > **And don't depend on the usb from the computer as it does not supply enough power!** **`especially when heavy loading the raspberry pi!`**
